import json
import os
import sqlite3
import secrets
import hashlib
import hmac
from datetime import datetime, timedelta
from http import HTTPStatus
from http.server import BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.getenv("COCOWORK_DB_PATH", "/tmp/cocowork.db")

DEFAULT_ADMIN_EMAIL = os.getenv("COCOWORK_ADMIN_EMAIL", "admin@cocowork.local")
DEFAULT_ADMIN_PASSWORD = os.getenv("COCOWORK_ADMIN_PASSWORD", "admin123")

DEFAULT_CONTRACT_TEMPLATE = """
COCOWORK OPEN OFFICE TABLE RENTAL AGREEMENT

This Agreement is between Cocowork and the Contractor listed below.
The Contractor agrees to rent one open office table at Cocowork and comply with
community guidelines, payment terms, and workspace policies.

Billing Terms:
- Monthly invoice generated by Cocowork.
- Payment due within 7 days of invoice date.

Signatures below confirm acceptance of this Agreement.
""".strip()


def now_iso():
    return datetime.utcnow().replace(microsecond=0).isoformat() + "Z"


def db_connect():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db():
    conn = db_connect()
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            role TEXT NOT NULL,
            created_at TEXT NOT NULL
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS profiles (
            user_id INTEGER PRIMARY KEY,
            full_name TEXT,
            company_type TEXT,
            company_name TEXT,
            tax_id TEXT,
            address TEXT,
            phone TEXT,
            bank_account TEXT,
            vat_payer INTEGER DEFAULT 0,
            vat_rate INTEGER DEFAULT 0,
            updated_at TEXT,
            FOREIGN KEY(user_id) REFERENCES users(id)
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS sessions (
            token TEXT PRIMARY KEY,
            user_id INTEGER NOT NULL,
            expires_at TEXT NOT NULL,
            FOREIGN KEY(user_id) REFERENCES users(id)
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS contract_templates (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            content TEXT NOT NULL,
            created_at TEXT NOT NULL,
            active INTEGER NOT NULL DEFAULT 1
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS contracts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            template_id INTEGER NOT NULL,
            content TEXT NOT NULL,
            contractor_signature TEXT,
            contractor_signed_at TEXT,
            admin_signature TEXT,
            admin_signed_at TEXT,
            updated_at TEXT NOT NULL,
            FOREIGN KEY(user_id) REFERENCES users(id),
            FOREIGN KEY(template_id) REFERENCES contract_templates(id)
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS invoices (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            invoice_number TEXT NOT NULL,
            user_id INTEGER NOT NULL,
            month TEXT NOT NULL,
            amount_cents INTEGER NOT NULL,
            vat_cents INTEGER NOT NULL DEFAULT 0,
            total_cents INTEGER NOT NULL DEFAULT 0,
            status TEXT NOT NULL,
            created_at TEXT NOT NULL,
            FOREIGN KEY(user_id) REFERENCES users(id)
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS invoice_sequences (
            month TEXT PRIMARY KEY,
            next_number INTEGER NOT NULL
        )
    """)
    conn.commit()

    # Lightweight migrations for existing DBs
    cur.execute("PRAGMA table_info(profiles)")
    profile_cols = {row[1] for row in cur.fetchall()}
    if "vat_payer" not in profile_cols:
        cur.execute("ALTER TABLE profiles ADD COLUMN vat_payer INTEGER DEFAULT 0")
    if "vat_rate" not in profile_cols:
        cur.execute("ALTER TABLE profiles ADD COLUMN vat_rate INTEGER DEFAULT 0")

    cur.execute("PRAGMA table_info(invoices)")
    invoice_cols = {row[1] for row in cur.fetchall()}
    if "vat_cents" not in invoice_cols:
        cur.execute("ALTER TABLE invoices ADD COLUMN vat_cents INTEGER NOT NULL DEFAULT 0")
    if "total_cents" not in invoice_cols:
        cur.execute("ALTER TABLE invoices ADD COLUMN total_cents INTEGER NOT NULL DEFAULT 0")
    conn.commit()

    cur.execute("SELECT id FROM contract_templates WHERE active = 1 ORDER BY id DESC LIMIT 1")
    row = cur.fetchone()
    if not row:
        cur.execute(
            "INSERT INTO contract_templates (content, created_at, active) VALUES (?, ?, 1)",
            (DEFAULT_CONTRACT_TEMPLATE, now_iso()),
        )
        conn.commit()

    cur.execute("SELECT id FROM users WHERE role = 'admin' LIMIT 1")
    admin = cur.fetchone()
    if not admin:
        password_hash = hash_password(DEFAULT_ADMIN_PASSWORD)
        cur.execute(
            "INSERT INTO users (email, password_hash, role, created_at) VALUES (?, ?, 'admin', ?)",
            (DEFAULT_ADMIN_EMAIL, password_hash, now_iso()),
        )
        conn.commit()

    conn.close()


def hash_password(password: str) -> str:
    salt = secrets.token_bytes(16)
    digest = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, 120000)
    return salt.hex() + "$" + digest.hex()


def verify_password(password: str, stored: str) -> bool:
    try:
        salt_hex, digest_hex = stored.split("$")
    except ValueError:
        return False
    salt = bytes.fromhex(salt_hex)
    expected = bytes.fromhex(digest_hex)
    test = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, 120000)
    return hmac.compare_digest(test, expected)


def parse_json(body: bytes):
    if not body:
        return {}
    try:
        return json.loads(body.decode("utf-8"))
    except json.JSONDecodeError:
        return None


def send_json(handler, payload, status=HTTPStatus.OK):
    data = json.dumps(payload).encode("utf-8")
    handler.send_response(status)
    handler.send_header("Content-Type", "application/json")
    handler.send_header("Content-Length", str(len(data)))
    handler.end_headers()
    handler.wfile.write(data)


def parse_amount_to_cents(value: str) -> int:
    value = value.strip()
    if value == "":
        raise ValueError("Empty amount")
    if value.startswith("$"):
        value = value[1:]
    parts = value.split(".")
    if len(parts) == 1:
        return int(parts[0]) * 100
    if len(parts) == 2:
        whole = int(parts[0]) if parts[0] else 0
        frac = parts[1].ljust(2, "0")[:2]
        return whole * 100 + int(frac)
    raise ValueError("Invalid amount")


def create_contract_for_user(conn, user_id: int):
    cur = conn.cursor()
    cur.execute("SELECT id, content FROM contract_templates WHERE active = 1 ORDER BY id DESC LIMIT 1")
    template = cur.fetchone()
    if not template:
        raise RuntimeError("No contract template")
    cur.execute(
        """
        INSERT INTO contracts (user_id, template_id, content, updated_at)
        VALUES (?, ?, ?, ?)
        """,
        (user_id, template["id"], template["content"], now_iso()),
    )


def get_user_from_session(token: str):
    if not token:
        return None
    conn = db_connect()
    cur = conn.cursor()
    cur.execute(
        """
        SELECT users.* FROM sessions
        JOIN users ON users.id = sessions.user_id
        WHERE sessions.token = ? AND sessions.expires_at > ?
        """,
        (token, now_iso()),
    )
    user = cur.fetchone()
    conn.close()
    return user


def create_session(conn, user_id: int) -> str:
    token = secrets.token_urlsafe(32)
    expires = (datetime.utcnow() + timedelta(days=7)).replace(microsecond=0).isoformat() + "Z"
    conn.execute(
        "INSERT INTO sessions (token, user_id, expires_at) VALUES (?, ?, ?)",
        (token, user_id, expires),
    )
    return token


def clear_session(conn, token: str):
    if token:
        conn.execute("DELETE FROM sessions WHERE token = ?", (token,))


def get_cookie(headers, name):
    cookie = headers.get("Cookie")
    if not cookie:
        return None
    parts = [p.strip() for p in cookie.split(";")]
    for part in parts:
        if part.startswith(name + "="):
            return part.split("=", 1)[1]
    return None


def ensure_profile(conn, user_id):
    cur = conn.cursor()
    cur.execute("SELECT user_id FROM profiles WHERE user_id = ?", (user_id,))
    row = cur.fetchone()
    if not row:
        cur.execute(
            "INSERT INTO profiles (user_id, updated_at) VALUES (?, ?)",
            (user_id, now_iso()),
        )


class handler(BaseHTTPRequestHandler):
    def do_OPTIONS(self):
        self.send_response(HTTPStatus.NO_CONTENT)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        self.end_headers()

    def do_GET(self):
        self.handle_api_get()

    def do_POST(self):
        self.handle_api_post()

    def handle_api_get(self):
        path = urlparse(self.path)
        route = path.path
        query = parse_qs(path.query)
        token = get_cookie(self.headers, "session")
        user = get_user_from_session(token)

        if route == "/api/me":
            if not user:
                send_json(self, {"ok": False, "error": "Not authenticated"}, HTTPStatus.UNAUTHORIZED)
                return
            conn = db_connect()
            cur = conn.cursor()
            cur.execute("SELECT * FROM profiles WHERE user_id = ?", (user["id"],))
            profile = cur.fetchone()
            conn.close()
            send_json(self, {
                "ok": True,
                "user": {
                    "id": user["id"],
                    "email": user["email"],
                    "role": user["role"],
                },
                "profile": dict(profile) if profile else None,
            })
            return

        if route == "/api/contract":
            if not user:
                send_json(self, {"ok": False, "error": "Not authenticated"}, HTTPStatus.UNAUTHORIZED)
                return
            conn = db_connect()
            cur = conn.cursor()
            if user["role"] == "admin":
                user_id = int(query.get("user_id", [0])[0])
            else:
                user_id = user["id"]
            cur.execute("SELECT * FROM contracts WHERE user_id = ? ORDER BY id DESC LIMIT 1", (user_id,))
            contract = cur.fetchone()
            conn.close()
            if not contract:
                send_json(self, {"ok": False, "error": "No contract"}, HTTPStatus.NOT_FOUND)
                return
            send_json(self, {"ok": True, "contract": dict(contract)})
            return

        if route == "/api/invoices":
            if not user:
                send_json(self, {"ok": False, "error": "Not authenticated"}, HTTPStatus.UNAUTHORIZED)
                return
            conn = db_connect()
            cur = conn.cursor()
            if user["role"] == "admin":
                month = query.get("month", [""])[0]
                if month:
                    cur.execute(
                        """
                        SELECT invoices.*, users.email, profiles.full_name, profiles.company_name
                        FROM invoices
                        JOIN users ON users.id = invoices.user_id
                        LEFT JOIN profiles ON profiles.user_id = users.id
                        WHERE invoices.month = ?
                        ORDER BY invoices.id DESC
                        """,
                        (month,),
                    )
                else:
                    cur.execute(
                        """
                        SELECT invoices.*, users.email, profiles.full_name, profiles.company_name
                        FROM invoices
                        JOIN users ON users.id = invoices.user_id
                        LEFT JOIN profiles ON profiles.user_id = users.id
                        ORDER BY invoices.id DESC
                        """
                    )
                rows = [dict(r) for r in cur.fetchall()]
                conn.close()
                send_json(self, {"ok": True, "invoices": rows})
                return

            cur.execute(
                "SELECT * FROM invoices WHERE user_id = ? ORDER BY month DESC, id DESC",
                (user["id"],),
            )
            rows = [dict(r) for r in cur.fetchall()]
            conn.close()
            send_json(self, {"ok": True, "invoices": rows})
            return

        if route == "/api/admin/contractors":
            if not user or user["role"] != "admin":
                send_json(self, {"ok": False, "error": "Not authorized"}, HTTPStatus.FORBIDDEN)
                return
            conn = db_connect()
            cur = conn.cursor()
            cur.execute(
                """
                SELECT users.id, users.email, profiles.full_name, profiles.company_name,
                       profiles.vat_payer, profiles.vat_rate,
                       contracts.contractor_signed_at, contracts.admin_signed_at
                FROM users
                LEFT JOIN profiles ON profiles.user_id = users.id
                LEFT JOIN contracts ON contracts.user_id = users.id
                WHERE users.role = 'contractor'
                GROUP BY users.id
                ORDER BY users.id DESC
                """
            )
            rows = [dict(r) for r in cur.fetchall()]
            conn.close()
            send_json(self, {"ok": True, "contractors": rows})
            return

        if route == "/api/admin/contractor":
            if not user or user["role"] != "admin":
                send_json(self, {"ok": False, "error": "Not authorized"}, HTTPStatus.FORBIDDEN)
                return
            user_id = int(query.get("user_id", [0])[0])
            conn = db_connect()
            cur = conn.cursor()
            cur.execute("SELECT * FROM users WHERE id = ?", (user_id,))
            u = cur.fetchone()
            cur.execute("SELECT * FROM profiles WHERE user_id = ?", (user_id,))
            p = cur.fetchone()
            cur.execute("SELECT * FROM contracts WHERE user_id = ? ORDER BY id DESC LIMIT 1", (user_id,))
            c = cur.fetchone()
            cur.execute(
                "SELECT * FROM invoices WHERE user_id = ? ORDER BY month DESC, id DESC",
                (user_id,),
            )
            invoices = [dict(r) for r in cur.fetchall()]
            conn.close()
            send_json(self, {
                "ok": True,
                "user": dict(u) if u else None,
                "profile": dict(p) if p else None,
                "contract": dict(c) if c else None,
                "invoices": invoices,
            })
            return

        send_json(self, {"ok": False, "error": "Not found"}, HTTPStatus.NOT_FOUND)

    def handle_api_post(self):
        path = urlparse(self.path).path
        length = int(self.headers.get("Content-Length", 0))
        body = self.rfile.read(length)
        data = parse_json(body)
        if data is None:
            send_json(self, {"ok": False, "error": "Invalid JSON"}, HTTPStatus.BAD_REQUEST)
            return

        token = get_cookie(self.headers, "session")
        user = get_user_from_session(token)

        if path == "/api/register":
            email = (data.get("email") or "").strip().lower()
            password = data.get("password") or ""
            full_name = (data.get("full_name") or "").strip()
            if not email or not password:
                send_json(self, {"ok": False, "error": "Email and password required"}, HTTPStatus.BAD_REQUEST)
                return
            conn = db_connect()
            cur = conn.cursor()
            try:
                cur.execute(
                    "INSERT INTO users (email, password_hash, role, created_at) VALUES (?, ?, 'contractor', ?)",
                    (email, hash_password(password), now_iso()),
                )
                user_id = cur.lastrowid
                ensure_profile(conn, user_id)
                if full_name:
                    cur.execute(
                        "UPDATE profiles SET full_name = ?, updated_at = ? WHERE user_id = ?",
                        (full_name, now_iso(), user_id),
                    )
                create_contract_for_user(conn, user_id)
                conn.commit()
            except sqlite3.IntegrityError:
                conn.close()
                send_json(self, {"ok": False, "error": "Email already in use"}, HTTPStatus.CONFLICT)
                return
            conn.close()
            send_json(self, {"ok": True})
            return

        if path == "/api/login":
            email = (data.get("email") or "").strip().lower()
            password = data.get("password") or ""
            role = (data.get("role") or "").strip()
            conn = db_connect()
            cur = conn.cursor()
            cur.execute("SELECT * FROM users WHERE email = ?", (email,))
            row = cur.fetchone()
            if not row or not verify_password(password, row["password_hash"]):
                conn.close()
                send_json(self, {"ok": False, "error": "Invalid credentials"}, HTTPStatus.UNAUTHORIZED)
                return
            if role and row["role"] != role:
                conn.close()
                send_json(self, {"ok": False, "error": "Wrong portal for this account"}, HTTPStatus.UNAUTHORIZED)
                return
            token = create_session(conn, row["id"])
            conn.commit()
            conn.close()
            self.send_response(HTTPStatus.OK)
            self.send_header("Content-Type", "application/json")
            self.send_header("Set-Cookie", f"session={token}; HttpOnly; Path=/; SameSite=Lax")
            payload = json.dumps({"ok": True}).encode("utf-8")
            self.send_header("Content-Length", str(len(payload)))
            self.end_headers()
            self.wfile.write(payload)
            return

        if path == "/api/logout":
            if not user:
                send_json(self, {"ok": True})
                return
            conn = db_connect()
            clear_session(conn, token)
            conn.commit()
            conn.close()
            self.send_response(HTTPStatus.OK)
            self.send_header("Content-Type", "application/json")
            self.send_header("Set-Cookie", "session=; HttpOnly; Path=/; Max-Age=0; SameSite=Lax")
            payload = json.dumps({"ok": True}).encode("utf-8")
            self.send_header("Content-Length", str(len(payload)))
            self.end_headers()
            self.wfile.write(payload)
            return

        if path == "/api/profile":
            if not user:
                send_json(self, {"ok": False, "error": "Not authenticated"}, HTTPStatus.UNAUTHORIZED)
                return
            conn = db_connect()
            ensure_profile(conn, user["id"])
            vat_payer = 1 if str(data.get("vat_payer")).lower() in ("1", "true", "on", "yes") else 0
            try:
                vat_rate = int(data.get("vat_rate") or 0)
            except ValueError:
                vat_rate = 0
            conn.execute(
                """
                UPDATE profiles SET
                    full_name = ?, company_type = ?, company_name = ?, tax_id = ?,
                    address = ?, phone = ?, bank_account = ?, vat_payer = ?, vat_rate = ?, updated_at = ?
                WHERE user_id = ?
                """,
                (
                    data.get("full_name"),
                    data.get("company_type"),
                    data.get("company_name"),
                    data.get("tax_id"),
                    data.get("address"),
                    data.get("phone"),
                    data.get("bank_account"),
                    vat_payer,
                    vat_rate,
                    now_iso(),
                    user["id"],
                ),
            )
            conn.commit()
            conn.close()
            send_json(self, {"ok": True})
            return

        if path == "/api/contract/sign":
            if not user:
                send_json(self, {"ok": False, "error": "Not authenticated"}, HTTPStatus.UNAUTHORIZED)
                return
            signature = (data.get("signature") or "").strip()
            if not signature:
                send_json(self, {"ok": False, "error": "Signature required"}, HTTPStatus.BAD_REQUEST)
                return
            conn = db_connect()
            cur = conn.cursor()
            if user["role"] == "admin":
                user_id = int(data.get("user_id") or 0)
            else:
                user_id = user["id"]
            cur.execute("SELECT * FROM contracts WHERE user_id = ? ORDER BY id DESC LIMIT 1", (user_id,))
            contract = cur.fetchone()
            if not contract:
                conn.close()
                send_json(self, {"ok": False, "error": "No contract"}, HTTPStatus.NOT_FOUND)
                return
            if user["role"] == "admin":
                cur.execute(
                    """
                    UPDATE contracts SET admin_signature = ?, admin_signed_at = ?, updated_at = ?
                    WHERE id = ?
                    """,
                    (signature, now_iso(), now_iso(), contract["id"]),
                )
            else:
                cur.execute(
                    """
                    UPDATE contracts SET contractor_signature = ?, contractor_signed_at = ?, updated_at = ?
                    WHERE id = ?
                    """,
                    (signature, now_iso(), now_iso(), contract["id"]),
                )
            conn.commit()
            conn.close()
            send_json(self, {"ok": True})
            return

        if path == "/api/admin/contract/update":
            if not user or user["role"] != "admin":
                send_json(self, {"ok": False, "error": "Not authorized"}, HTTPStatus.FORBIDDEN)
                return
            content = (data.get("content") or "").strip()
            apply_to_unsigned = bool(data.get("apply_to_unsigned"))
            if not content:
                send_json(self, {"ok": False, "error": "Content required"}, HTTPStatus.BAD_REQUEST)
                return
            conn = db_connect()
            cur = conn.cursor()
            cur.execute("UPDATE contract_templates SET active = 0")
            cur.execute(
                "INSERT INTO contract_templates (content, created_at, active) VALUES (?, ?, 1)",
                (content, now_iso()),
            )
            template_id = cur.lastrowid
            if apply_to_unsigned:
                cur.execute(
                    """
                    UPDATE contracts
                    SET content = ?, template_id = ?, updated_at = ?
                    WHERE contractor_signed_at IS NULL
                    """,
                    (content, template_id, now_iso()),
                )
            conn.commit()
            conn.close()
            send_json(self, {"ok": True})
            return

        if path == "/api/admin/contractor/contract/update":
            if not user or user["role"] != "admin":
                send_json(self, {"ok": False, "error": "Not authorized"}, HTTPStatus.FORBIDDEN)
                return
            user_id = int(data.get("user_id") or 0)
            content = (data.get("content") or "").strip()
            reset_signatures = bool(data.get("reset_signatures", True))
            if not user_id or not content:
                send_json(self, {"ok": False, "error": "User and content required"}, HTTPStatus.BAD_REQUEST)
                return
            conn = db_connect()
            cur = conn.cursor()
            cur.execute("SELECT id FROM contracts WHERE user_id = ? ORDER BY id DESC LIMIT 1", (user_id,))
            contract = cur.fetchone()
            if not contract:
                conn.close()
                send_json(self, {"ok": False, "error": "No contract"}, HTTPStatus.NOT_FOUND)
                return
            if reset_signatures:
                cur.execute(
                    """
                    UPDATE contracts
                    SET content = ?, contractor_signature = NULL, contractor_signed_at = NULL,
                        admin_signature = NULL, admin_signed_at = NULL, updated_at = ?
                    WHERE id = ?
                    """,
                    (content, now_iso(), contract["id"]),
                )
            else:
                cur.execute(
                    "UPDATE contracts SET content = ?, updated_at = ? WHERE id = ?",
                    (content, now_iso(), contract["id"]),
                )
            conn.commit()
            conn.close()
            send_json(self, {"ok": True})
            return

        if path == "/api/admin/invoices/generate":
            if not user or user["role"] != "admin":
                send_json(self, {"ok": False, "error": "Not authorized"}, HTTPStatus.FORBIDDEN)
                return
            month = (data.get("month") or "").strip()
            total_amount = (data.get("total_amount") or "").strip()
            if not month or not total_amount:
                send_json(self, {"ok": False, "error": "Month and total amount required"}, HTTPStatus.BAD_REQUEST)
                return
            try:
                total_cents = parse_amount_to_cents(total_amount)
            except ValueError:
                send_json(self, {"ok": False, "error": "Invalid amount"}, HTTPStatus.BAD_REQUEST)
                return
            conn = db_connect()
            cur = conn.cursor()
            cur.execute(
                """
                SELECT users.id, profiles.vat_payer, profiles.vat_rate
                FROM users
                LEFT JOIN profiles ON profiles.user_id = users.id
                WHERE users.role = 'contractor'
                ORDER BY users.id ASC
                """
            )
            contractors = cur.fetchall()
            if not contractors:
                conn.close()
                send_json(self, {"ok": False, "error": "No contractors"}, HTTPStatus.BAD_REQUEST)
                return
            count = len(contractors)
            base = total_cents // count
            remainder = total_cents % count
            cur.execute("SELECT next_number FROM invoice_sequences WHERE month = ?", (month,))
            seq = cur.fetchone()
            next_number = seq["next_number"] if seq else 1

            for i, row in enumerate(contractors):
                user_id = row["id"]
                amount_cents = base + (1 if i < remainder else 0)
                vat_rate = int(row["vat_rate"] or 0)
                vat_payer = int(row["vat_payer"] or 0)
                vat_cents = (amount_cents * vat_rate // 100) if vat_payer and vat_rate > 0 else 0
                total_cents_row = amount_cents + vat_cents
                invoice_number = f"INV-{month.replace('-', '')}-{next_number:04d}"
                next_number += 1
                cur.execute(
                    """
                    INSERT INTO invoices (invoice_number, user_id, month, amount_cents, vat_cents, total_cents, status, created_at)
                    VALUES (?, ?, ?, ?, ?, ?, 'unpaid', ?)
                    """,
                    (invoice_number, user_id, month, amount_cents, vat_cents, total_cents_row, now_iso()),
                )
            cur.execute(
                "INSERT OR REPLACE INTO invoice_sequences (month, next_number) VALUES (?, ?)",
                (month, next_number),
            )
            conn.commit()
            conn.close()
            send_json(self, {"ok": True})
            return

        if path == "/api/admin/invoice/mark-paid":
            if not user or user["role"] != "admin":
                send_json(self, {"ok": False, "error": "Not authorized"}, HTTPStatus.FORBIDDEN)
                return
            invoice_id = int(data.get("invoice_id") or 0)
            paid = bool(data.get("paid"))
            status = "paid" if paid else "unpaid"
            conn = db_connect()
            conn.execute("UPDATE invoices SET status = ? WHERE id = ?", (status, invoice_id))
            conn.commit()
            conn.close()
            send_json(self, {"ok": True})
            return

        send_json(self, {"ok": False, "error": "Not found"}, HTTPStatus.NOT_FOUND)


init_db()
